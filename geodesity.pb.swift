// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: geodesity.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Protobuf specifications for Geodesity binary communications.
//
// Supports Python, Go, Swift, C#, and Java (Android Studio)
// (Currently only Java and C# are explicitly defined.)
//
// For more information, refer to the README

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enums
enum EventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case eventInvalid // = 0
  case eventHeartbeat // = 1
  case eventPositionTimed // = 2
  case eventIdleNotify // = 3
  case eventParkNotify // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .eventInvalid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .eventInvalid
    case 1: self = .eventHeartbeat
    case 2: self = .eventPositionTimed
    case 3: self = .eventIdleNotify
    case 4: self = .eventParkNotify
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .eventInvalid: return 0
    case .eventHeartbeat: return 1
    case .eventPositionTimed: return 2
    case .eventIdleNotify: return 3
    case .eventParkNotify: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum NotifyType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notifyInvalid // = 0
  case notifyEnterIdle // = 1
  case notifyContinueIdle // = 2
  case notifyLeaveIdle // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .notifyInvalid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notifyInvalid
    case 1: self = .notifyEnterIdle
    case 2: self = .notifyContinueIdle
    case 3: self = .notifyLeaveIdle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notifyInvalid: return 0
    case .notifyEnterIdle: return 1
    case .notifyContinueIdle: return 2
    case .notifyLeaveIdle: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Main Event - All protocols derive from this message.
struct Event: SwiftProtobuf.Message {
  static let protoMessageName: String = "Event"

  /// id is a string of any length; "10000123", "TEST-01", or an IMEI
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// explicitly declared to make for easy switching by parsers
  var type: EventType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// UTC/Unix-epoch of moment when the message was created
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_storage._timestamp = nil}

  /// Each Event type is included here with a unique protobuf Tag
  var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  /// Tags are in the range of 100-299
  var heartbeat: Heartbeat {
    get {
      if case .heartbeat(let v)? = _storage._details {return v}
      return Heartbeat()
    }
    set {_uniqueStorage()._details = .heartbeat(newValue)}
  }

  /// Sub-message formats are described below.
  var position: Position {
    get {
      if case .position(let v)? = _storage._details {return v}
      return Position()
    }
    set {_uniqueStorage()._details = .position(newValue)}
  }

  /// Only one Event type can exist at a time (oneof)
  var idleNotify: IdleNotify {
    get {
      if case .idleNotify(let v)? = _storage._details {return v}
      return IdleNotify()
    }
    set {_uniqueStorage()._details = .idleNotify(newValue)}
  }

  var parkNotify: ParkNotify {
    get {
      if case .parkNotify(let v)? = _storage._details {return v}
      return ParkNotify()
    }
    set {_uniqueStorage()._details = .parkNotify(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Each Event type is included here with a unique protobuf Tag
  enum OneOf_Details: Equatable {
    /// Tags are in the range of 100-299
    case heartbeat(Heartbeat)
    /// Sub-message formats are described below.
    case position(Position)
    /// Only one Event type can exist at a time (oneof)
    case idleNotify(IdleNotify)
    case parkNotify(ParkNotify)

    static func ==(lhs: Event.OneOf_Details, rhs: Event.OneOf_Details) -> Bool {
      switch (lhs, rhs) {
      case (.heartbeat(let l), .heartbeat(let r)): return l == r
      case (.position(let l), .position(let r)): return l == r
      case (.idleNotify(let l), .idleNotify(let r)): return l == r
      case (.parkNotify(let l), .parkNotify(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        case 100:
          var v: Heartbeat?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .heartbeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .heartbeat(v)}
        case 101:
          var v: Position?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .position(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .position(v)}
        case 102:
          var v: IdleNotify?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .idleNotify(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .idleNotify(v)}
        case 103:
          var v: ParkNotify?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .parkNotify(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .parkNotify(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .eventInvalid {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      switch _storage._details {
      case .heartbeat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .position(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case .idleNotify(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      case .parkNotify(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Heartbeat - Device wakeup/keep-alive message
struct Heartbeat: SwiftProtobuf.Message {
  static let protoMessageName: String = "Heartbeat"

  /// sequential counter; wraps at max-int32
  var sequence: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 300: try decoder.decodeSingularUInt32Field(value: &self.sequence)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 300)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Position - General location message
struct Position: SwiftProtobuf.Message {
  static let protoMessageName: String = "Position"

  var longitude: Float = 0

  var latitude: Float = 0

  var altitude: Float = 0

  var course: Float = 0

  var speed: Float = 0

  var odometer: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 301: try decoder.decodeSingularFloatField(value: &self.longitude)
      case 302: try decoder.decodeSingularFloatField(value: &self.latitude)
      case 303: try decoder.decodeSingularFloatField(value: &self.altitude)
      case 304: try decoder.decodeSingularFloatField(value: &self.course)
      case 305: try decoder.decodeSingularFloatField(value: &self.speed)
      case 306: try decoder.decodeSingularFloatField(value: &self.odometer)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 301)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 302)
    }
    if self.altitude != 0 {
      try visitor.visitSingularFloatField(value: self.altitude, fieldNumber: 303)
    }
    if self.course != 0 {
      try visitor.visitSingularFloatField(value: self.course, fieldNumber: 304)
    }
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 305)
    }
    if self.odometer != 0 {
      try visitor.visitSingularFloatField(value: self.odometer, fieldNumber: 306)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// IdleNotify - Reported when a device recognizes idle start, continue, or end
struct IdleNotify: SwiftProtobuf.Message {
  static let protoMessageName: String = "IdleNotify"

  var positionTimed: Position {
    get {return _storage._positionTimed ?? Position()}
    set {_uniqueStorage()._positionTimed = newValue}
  }
  /// Returns true if `positionTimed` has been explicitly set.
  var hasPositionTimed: Bool {return _storage._positionTimed != nil}
  /// Clears the value of `positionTimed`. Subsequent reads from it will return its default value.
  mutating func clearPositionTimed() {_storage._positionTimed = nil}

  var type: NotifyType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var seconds: UInt32 {
    get {return _storage._seconds}
    set {_uniqueStorage()._seconds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 307: try decoder.decodeSingularMessageField(value: &_storage._positionTimed)
        case 308: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 309: try decoder.decodeSingularUInt32Field(value: &_storage._seconds)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._positionTimed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 307)
      }
      if _storage._type != .notifyInvalid {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 308)
      }
      if _storage._seconds != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seconds, fieldNumber: 309)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ParkNotify - Reported when a device recognizes park start, continue, or end
struct ParkNotify: SwiftProtobuf.Message {
  static let protoMessageName: String = "ParkNotify"

  var positionTimed: Position {
    get {return _storage._positionTimed ?? Position()}
    set {_uniqueStorage()._positionTimed = newValue}
  }
  /// Returns true if `positionTimed` has been explicitly set.
  var hasPositionTimed: Bool {return _storage._positionTimed != nil}
  /// Clears the value of `positionTimed`. Subsequent reads from it will return its default value.
  mutating func clearPositionTimed() {_storage._positionTimed = nil}

  var type: NotifyType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var seconds: UInt32 {
    get {return _storage._seconds}
    set {_uniqueStorage()._seconds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 310: try decoder.decodeSingularMessageField(value: &_storage._positionTimed)
        case 311: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 312: try decoder.decodeSingularUInt32Field(value: &_storage._seconds)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._positionTimed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 310)
      }
      if _storage._type != .notifyInvalid {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 311)
      }
      if _storage._seconds != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seconds, fieldNumber: 312)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_INVALID"),
    1: .same(proto: "EVENT_HEARTBEAT"),
    2: .same(proto: "EVENT_POSITION_TIMED"),
    3: .same(proto: "EVENT_IDLE_NOTIFY"),
    4: .same(proto: "EVENT_PARK_NOTIFY"),
  ]
}

extension NotifyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTIFY_INVALID"),
    1: .same(proto: "NOTIFY_ENTER_IDLE"),
    2: .same(proto: "NOTIFY_CONTINUE_IDLE"),
    3: .same(proto: "NOTIFY_LEAVE_IDLE"),
  ]
}

extension Event: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "timestamp"),
    100: .same(proto: "heartbeat"),
    101: .same(proto: "position"),
    102: .standard(proto: "idle_notify"),
    103: .standard(proto: "park_notify"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: EventType = .eventInvalid
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _details: Event.OneOf_Details?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _timestamp = source._timestamp
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Event) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        if _storage._type != other_storage._type {return false}
        if _storage._timestamp != other_storage._timestamp {return false}
        if _storage._details != other_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Heartbeat: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    300: .same(proto: "sequence"),
  ]

  func _protobuf_generated_isEqualTo(other: Heartbeat) -> Bool {
    if self.sequence != other.sequence {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Position: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    301: .same(proto: "longitude"),
    302: .same(proto: "latitude"),
    303: .same(proto: "altitude"),
    304: .same(proto: "course"),
    305: .same(proto: "speed"),
    306: .same(proto: "odometer"),
  ]

  func _protobuf_generated_isEqualTo(other: Position) -> Bool {
    if self.longitude != other.longitude {return false}
    if self.latitude != other.latitude {return false}
    if self.altitude != other.altitude {return false}
    if self.course != other.course {return false}
    if self.speed != other.speed {return false}
    if self.odometer != other.odometer {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension IdleNotify: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    307: .standard(proto: "position_timed"),
    308: .same(proto: "type"),
    309: .same(proto: "seconds"),
  ]

  fileprivate class _StorageClass {
    var _positionTimed: Position? = nil
    var _type: NotifyType = .notifyInvalid
    var _seconds: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _positionTimed = source._positionTimed
      _type = source._type
      _seconds = source._seconds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: IdleNotify) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._positionTimed != other_storage._positionTimed {return false}
        if _storage._type != other_storage._type {return false}
        if _storage._seconds != other_storage._seconds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ParkNotify: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    310: .standard(proto: "position_timed"),
    311: .same(proto: "type"),
    312: .same(proto: "seconds"),
  ]

  fileprivate class _StorageClass {
    var _positionTimed: Position? = nil
    var _type: NotifyType = .notifyInvalid
    var _seconds: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _positionTimed = source._positionTimed
      _type = source._type
      _seconds = source._seconds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: ParkNotify) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._positionTimed != other_storage._positionTimed {return false}
        if _storage._type != other_storage._type {return false}
        if _storage._seconds != other_storage._seconds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
